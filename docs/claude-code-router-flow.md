# Claude Code Router 请求流程分析

## 概述

Claude Code Router 是一个基于 TypeScript 的智能路由器，用于将 Claude Code 的请求转发到不同的 LLM 提供商。本文档详细分析了从用户执行 `ccr code` 命令到获得完整响应的完整流程。

## 整体架构

```
用户命令 → CLI入口 → 服务检查 → 环境配置 → Claude Code执行 → HTTP请求 → 路由器服务 → 中间件处理 → 智能路由 → 提供商转发 → 响应返回
```

## 详细请求流程

### 1. 命令入口 (`src/cli.ts`)

当用户执行 `ccr code "your prompt"` 时：

1. **命令解析** (第17行): 解析命令行参数，识别 `code` 命令
2. **服务检查** (第111行): 检查路由器服务是否正在运行
3. **自动启动服务** (第112-147行): 如果服务未运行，自动启动后台服务
4. **等待服务就绪** (第138行): 使用 `waitForService()` 等待服务完全启动
5. **执行Claude命令** (第141行): 调用 `executeCodeCommand()` 执行实际的Claude Code命令

### 2. Claude Code 执行 (`src/utils/codeCommand.ts`)

`executeCodeCommand()` 函数负责配置和启动 Claude Code：

1. **配置读取** (第11行): 读取路由器配置文件
2. **环境变量设置** (第12-18行):
   - `ANTHROPIC_AUTH_TOKEN`: 设置认证令牌
   - `ANTHROPIC_BASE_URL`: 指向本地路由器服务 (`http://127.0.0.1:PORT`)
   - `API_TIMEOUT_MS`: API超时时间
3. **状态行配置** (第19-29行): 如果启用了状态行，添加相关配置
4. **非交互模式** (第32-37行): 根据配置设置非交互模式环境变量
5. **进程管理** (第49-50行): 增加引用计数，用于服务生命周期管理
6. **Claude Code启动** (第67-75行): 使用配置的环境变量启动 Claude Code 进程

### 3. HTTP请求到达路由器服务 (`src/index.ts`)

当 Claude Code 发送 HTTP 请求到路由器时：

1. **服务初始化** (第45-183行): `run()` 函数初始化服务器
2. **中间件注册** (第122-181行): 注册两个关键的 preHandler 钩子
3. **认证中间件** (第122-131行): API密钥认证
4. **路由中间件** (第132-136行): 对 `/v1/messages` 请求进行路由处理
5. **响应处理** (第137-181行): `onSend` 钩子处理响应和用量统计

### 4. 认证处理 (`src/middleware/auth.ts`)

`apiKeyAuth` 中间件处理请求认证：

1. **公开端点** (第7行): `/`, `/health`, `/ui/*` 无需认证
2. **API密钥检查** (第11-26行): 如果未设置API密钥，仅允许本地访问
3. **配置端点权限** (第27-68行): `/api/config` 和 `/api/restart` 端点的细粒度权限控制
4. **标准认证** (第70-92行): 其他端点的标准API密钥认证

### 5. 智能路由 (`src/utils/router.ts`)

`router()` 函数实现核心的路由逻辑：

1. **会话ID解析** (第143-149行): 从 `metadata.user_id` 提取会话ID
2. **用量缓存获取** (第150行): 获取该会话的上次用量数据
3. **Token计算** (第152-157行): 使用 `calculateTokenCount()` 计算请求的token数量
4. **自定义路由器** (第160-168行): 如果配置了自定义路由器，优先使用
5. **智能模型选择** (第169-171行): 调用 `getUseModel()` 进行智能路由决策

#### 智能路由决策逻辑 (`getUseModel` 函数):

1. **显式模型指定** (第72-84行): 如果请求中包含逗号分隔的 `provider,model` 格式
2. **长上下文检测** (第85-103行): 基于token数量和阈值使用长上下文模型
3. **子代理模型** (第104-118行): 解析系统消息中的 `<CCR-SUBAGENT-MODEL>` 标签
4. **后台任务模型** (第119-126行): 对 `claude-3-5-haiku` 使用后台模型
5. **思考模式模型** (第127-131行): 如果启用思考模式，使用专用模型
6. **网络搜索模型** (第132-138行): 如果包含网络搜索工具，使用专用模型
7. **默认模型** (第139行): 回退到配置的默认模型

### 6. Token计算 (`calculateTokenCount` 函数)

精确计算请求的token数量：

1. **消息内容** (第18-37行): 处理文本和工具使用/结果内容
2. **系统消息** (第39-52行): 处理系统提示内容
3. **工具定义** (第53-62行): 计算工具描述和输入schema的token数量

### 7. 响应处理和用量统计 (`src/index.ts` 第137-181行)

`onSend` 钩子处理响应：

1. **流式响应处理** (第139-160行): 对 `ReadableStream` 响应进行克隆和处理
2. **用量提取** (第148-155行): 从 `message_delta` 事件中提取用量数据
3. **缓存更新** (第154行): 将用量数据存储到会话缓存中
4. **非流式响应** (第161-179行): 处理常规JSON响应的用量统计

### 8. 缓存机制 (`src/utils/cache.ts`)

使用LRU缓存管理会话用量数据：

1. **LRUCache类** (第8-45行): 实现最近最少使用缓存算法
2. **会话用量缓存** (第47行): 容量为100的会话用量缓存
3. **自动清理** (第32-38行): 当缓存满时自动清理最久未使用的条目

### 9. 日志记录 (`src/utils/log.ts`)

提供统一的日志记录功能：

1. **配置管理** (第17-20行): 根据配置启用/禁用日志和设置日志级别
2. **日志写入** (第22-45行): 格式化日志消息并写入文件
3. **时间戳** (第32-33行): 为每条日志添加ISO格式时间戳

## 关键配置项

### 路由配置 (`config.example.json` 第171-177行)

```json
"Router": {
  "default": "gemini-cli,gemini-2.5-pro",
  "background": "gemini-cli,gemini-2.5-flash", 
  "think": "gemini-cli,gemini-2.5-pro",
  "longContext": "gemini-cli,gemini-2.5-pro",
  "webSearch": "gemini-cli,gemini-2.5-flash"
}
```

### 提供商配置

每个提供商包含：
- `name`: 提供商名称
- `api_base_url`: API基础URL
- `api_key`: API密钥
- `models`: 支持的模型列表
- `transformer`: 可选的转换器配置

## 错误处理和容错

1. **服务启动失败**: CLI会提供详细的错误信息和解决建议
2. **自定义路由器错误**: 如果自定义路由器加载失败，回退到内置路由逻辑
3. **认证失败**: 返回适当的HTTP状态码和错误消息
4. **模型选择失败**: 回退到配置的默认模型

## 性能优化

1. **缓存机制**: 使用LRU缓存避免重复计算
2. **流式处理**: 支持流式响应以减少延迟
3. **后台服务**: 服务在后台持续运行，避免重复启动开销
4. **智能路由**: 根据请求特征选择最适合的模型，平衡性能和成本

## 安全考虑

1. **API密钥认证**: 支持Bearer token和x-api-key两种认证方式
2. **CORS控制**: 未设置API密钥时限制跨域访问
3. **本地访问限制**: 未认证时仅允许本地访问
4. **细粒度权限**: 配置和重启操作需要特殊权限

这个流程展示了Claude Code Router如何智能地将用户请求路由到最适合的LLM提供商，同时提供完整的认证、日志记录和性能监控功能。